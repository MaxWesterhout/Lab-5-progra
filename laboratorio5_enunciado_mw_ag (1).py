# -*- coding: utf-8 -*-
"""Laboratorio5_enunciado_MW_AG.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e0ONFc2hSzBrhXN21jGd3wsDOtd4r8r0

<h1><center>Laboratorio 5: El Pandas no muerde (act. II) 🐼</center></h1>

<center><strong>MDS7202: Laboratorio de Programación Científica para Ciencia de Datos</strong></center>

### Cuerpo Docente:

- Profesor: Ignacio Meza y Gabriel Iturra
- Auxiliar: Sebastián Tinoco
- Ayudante: Arturo Lazcano y Angelo Muñoz

### Equipo: SUPER IMPORTANTE - notebooks sin nombre no serán revisados

- Nombre de alumno 1: Maximiliano Westerhout
- Nombre de alumno 2: Alvaro Gallardo

### **Link de repositorio de GitHub:** `https://github.com/MaxWesterhout/Lab-5-progra.git`

# Temas a tratar

- Manejo de datos tabulares usando `pandas`. En esta segunda parte se incluye adicionalmente agregaciones, concatenaciones, merge y trabajo con strings.
- Visualizaciones interactivas de los datos con `plotly`.

### Reglas:

- **Grupos de máximo 2 personas**
- Cualquier duda fuera del horario de clases al foro. Mensajes al equipo docente serán respondidos por este medio.
- Prohibidas las copias.
- Pueden usar cualquer material del curso que estimen conveniente.

### Objetivos principales del laboratorio

- Aplicar y aprovechar las ventajas que nos ofrece la libreria `pandas` para manipular datos tabulares.
- Utilizar `plotly` para obtener información gráfica del dataset.

> **Nota**: El laboratorio deberá ser desarrollado sin el uso indiscriminado de iteradores nativos de python (aka "for", "while"). La idea es que aprendan a exprimir al máximo las funciones optimizadas que nos entrega `pandas`, las cuales vale mencionar, son bastante más eficientes que los iteradores nativos sobre DataFrames.

# Importamos librerias utiles 😸
"""

# Libreria Core del lab.
import numpy as np
import pandas as pd

from IPython.display import display

#Libreria para visualizar
#!pip install --upgrade plotly
import plotly.figure_factory as ff
import plotly.express as px

"""# 1. Rendimiento en Estudiantes 📚

<p align="center">
  <img src="https://drive.google.com/uc?export=view&id=1hZZaPQlZe4VupFOXt76_wjuUA5NpUhrw" width="300" height="300">
</p>

Para este laboratorio deberán continuar el Análisis Exploratorio de datos sobre el conjunto ```students_grades.csv```, el cual contiene una caracterización sobre el rendimiento y otros atributos de cada alumno de la *Universidad de la Cachaña* .
"""

# Si usted está utilizando Colabolatory le puede ser útil este código para cargar los archivos.
try:
    from google.colab import drive
    drive.mount("/content/drive")
    path = 'Dirección donde tiene los archivos en el Drive'
except:
    print('Ignorando conexión drive-colab')

"""# 1. Carga de Datos [0.5 Puntos]

Ya finalizado en análisis inicial, ud. y su equipo le entregaron a *Don Caguayo* (rector de la Universidad de la Cachaña) tanto los resultados del análisis como también la base de datos limpia y lista para ser almacenada. Dada la ingente cantidad de los datos, el equipo de TI de la universidad resolvió separar el dataset en dos bases de datos distintas (lo que según argumentan ellos, permitiría hacer agregaciones de forma más eficiente).

Gracias a la excelente labor de ud. y su equipo en el análisis previo, el rector le solicita continuar el trabajo con una nueva batería de análisis. Por este motivo, la sección de TI les entrega nuevamente los datos. Sin embargo, argumentan que dada una escazes de personal, solo le entregarán *dumps* (copias) de cada base de datos y su equipo deberá unir las bases de datos. Los datos se encuentran en los siguiente archivos `.json`: `students_grades_1.json` y `students_grades_2.json`.


Por ende, ud. y su equipo deciden que la primera tarea se centrará en cargar estos datos y unirlos.

**No se preocupe por la limpieza ni transformar el tipo de datos de las columnas, ni tampoco transformar a notas chilenas**, recuerde que anteriormente ya se encargo de este tema.
"""

df_grades_1 = pd.read_json('students_grades_1.json')
df_grades_2 = pd.read_json('students_grades_2.json')
df_grades = pd.concat([df_grades_1,df_grades_2],axis=0)

df_grades

df_grades.dtypes

"""Resultado esperado:"""

df_grades

"""## Análisis de Las Notas v2 [0.5 Cada gráfico + 0.5 respuesta]

Preocupado por la dificultad que representa el graficar correctamente las notas, el rector le solicita implementar distintas alternativas de visualización.

Para esto, genere un [boxplot](https://plotly.com/python/box-plots/), un [displot](https://plotly.com/python/distplot/#distplot-with-pandas), un [histograma con un gráfico marginal de caja](https://plotly.com/python/histograms/#visualizing-the-distribution) y un [histograma con el ramo como faceta de fila](https://plotly.com/python/facet-plots/#histogram-facet-grids) que permitan visualizar las notas.

Luego, responda las siguientes pregunta:

> 1. ¿Existe una diferencia notable entre las notas?

> 2. ¿Cuál de los gráficos mostrados cree que es adecuado para mostrarle al rector? ¿Y a los padres? ¿Y a un centro de estudios educativos? ¿Por qué?. Base sus respuestas en lo visto en la clase de visualizaciones como también en lo que usted y su equipo consideren correcto.

> Hint: Para elaborar el histograma, puede que le sea de utilidad hacer un `melt` del DataFrame, dejando como variables los ramos y valores las notas. Por otra parte, visiten la documentación para generar los gráficos.

**Gráfico de Caja:**
"""

import plotly.graph_objects as go

y0 = df_grades['math score']
y1 = df_grades['reading score']
y2 = df_grades['writing score']

fig = go.Figure()
fig.add_trace(go.Box(y=y0,name= 'math score'))
fig.add_trace(go.Box(y=y1,name='reading score'))
fig.add_trace(go.Box(y=y2,name='writing score'))

fig.update_layout(
    title="Boxplot de las asignaturas",
    yaxis_title="Score")
fig.show()

"""**Distplot:**"""

#Agrupar datos
hist_data = [y0,y1,y2]

group_labels = ['math score', 'reading score', 'writing score']

# Create distplot with custom bin_size
fig = ff.create_distplot(hist_data,group_labels, show_hist=False, show_rug = False)

fig.update_layout(
    title="Displot de las asignaturas",
    yaxis_title="Probabilidad",
    xaxis_title='Score')
fig.show()

"""**Histograma con Boxplots:**"""

df_grades_melted = pd.melt(df_grades, id_vars=['names'], value_vars=['math score', 'reading score', 'writing score'],var_name='subject', value_name='score')

fig_hist = px.histogram(df_grades_melted, x='score', color='subject', marginal='box', title='Histograma con Boxplot para las Notas por Materia',barmode = "group", nbins=14)

fig_hist.show()

"""**Histograma con Faceta:**"""

fig_hist = px.histogram(df_grades_melted, x='score', color='subject', title='Histograma de Faceta para las Notas por Materia',barmode = "relative", nbins=14,facet_col='subject',facet_col_wrap=1)
fig_hist.show()

"""**Justifique:**

```
Escriba aquí su justificación

Respondiendo las preguntas tenemos lo siguiente:
¿Existe una diferencia notable entre las notas?

A priori si existen diferencias entre las notas pero son levemente similares para las tres asignaturas, esto se puede observar en todos los graficos en donde para el boxplot se puede notar que la mediana reading score y writing score es levemente superior que la de math score, pero que los rangos donde se distribuyen las notas son basicamente los mismos (quartile 1 y 3). Al ver el segundo grafico (displot), se puede observar que probabilisticamente los datos de writing score y reading score se tienden a distribuir mayoritariamente entre 5 y 6 levemente mas a la derecha que math score lo cual se relaciona con el resultado anterior dado que la mediana es mayor para dichas asignaturas. Para los ultimos 2 graficos se desprende basicamente la misma informacion anterior, a diferencia de que la viluazacion permite notar mas el contraste entre las asignaturas, por ejemplo, que existen mas 7.0s para la asignatura de reading.

En sintesis sí existen diferencias entre las asignaturas pero no son notables, dado que las medianas y distribuciones de ellas son distintas pero muy similares, habiendo mejores notas para las asignaturas de reading y writing. Cabe destacar que el displot muestra las distribuciones de las notas a lo largo de los distintos scores, donde se observan campanas gaussianas/normales para las tres asignaturas, por ello se asocia que estas tres presentas distribuciones similares a diferencia de sus medias.


¿Cuál de los gráficos mostrados cree que es adecuado para mostrarle al rector? ¿Y a los padres? ¿Y a un centro de estudios educativos? ¿Por qué?. Base sus respuestas en lo visto en la clase de visualizaciones como también en lo que usted y su equipo consideren correcto.

En terminos de informacion el mejor grafico corresponde al tercero dado que muestra la informacion de los boxplot sumado a la distribucion de los datos del displot, con ellos podria decirle a los padres cual es el promedio de las asignatura de sus hijxs al igual que la cantidad de estudiantes entre rangos de notas. Ahora dicho grafico no es tan simple de leer, pero es el mas completo a diferencia del 2 y 4 que son mas simples, por lo tanto, si puediera explicar el grafico en cuestion presentaria el 3 y si no pudiera hacer eso, dejaria imagenes del 2 y 4 dado que estos ultimos dos dejan claro que las notas estan en ciertos margenes (no exactos) lo cual es lo que los padres/rector quieren saber.

## Análisis por Nivel Educacional Etnia de los Padres [1.5 Puntos]

El rector, basado en su experiencia, cree fuertemente que el nivel educacional y la etnia de los padres influyen en las notas que obtienen sus hijos.
Como científicos de datos, ud. y su equipo creen que deben encontrar evidencia para confirmar o refutar la hipótesis del rector.

Para esto, deciden generar dos análisis: una tabla de resumen por una parte y gráficos de caja por otro.

### Tabla de Resumen

Para generar la tabla de resumen:

- [ ] Calcular el promedio de las notas y guardarlo en una variable `GPA` (grade point average).
- [ ] Hacer una simplificación a través de un mapeo (investigar el método `map()`) de la variable `parental level of education`  según la siguiente conversión:

        some high school -> school
        some college -> school
        high school -> school
        bachelor's degree -> college
        associate's degree -> college
        master's degree -> postgraduate

  Los resultados de este mapeo deben ser guardados en la columna `simple parental level of education`.


- [ ] Agregar según 2 niveles: `race/ethnicity` y `simple parental level of education` para obtener el promedio de las notas.
- [ ] Agregar según 2 niveles: `race/ethnicity` y `simple parental level of education` para obtener un conteo de los alumnos en cada grupo y agregarlos como una nueva fila count.
- [ ] Obtener el porcentaje de alumnos con respecto al total. Los porcentajes deben ser strings que contienen la frecuencia de cada grupo con respecto al total y deben ser terminados en '%'.


Utilizar la tabla de resultados esperados como guía para desarrollar este punto.

### 1.3.4 Información por Categorías [1 punto]
"""

df_grades

#Funcion para sacar promedio
def alumnos_promedio(df_grades):
  #Se aplica promedio
  promedio = (df_grades["math score"] + df_grades["reading score"] + df_grades["writing score"]) / 3
  #Se reemplazan los valores
  df_grades["GPA"] = promedio
  #Se retorna el dataframe
  return df_grades

#Mapeo del enunciado
df_grades = alumnos_promedio(df_grades)
mapeo = {
    'some high school': 'school',
    'some college': 'school',
    'high school': 'school',
    "bachelor's degree": 'college',
    "associate's degree": 'college',
    "master's degree": 'postgraduate'
}

df_grades['simplification parental level of education'] = df_grades['parental level of education'].map(mapeo)

tabla_resumen = df_grades.groupby(['race/ethnicity', 'simplification parental level of education']).mean(["math score","reading score","writing score"]).round(2)
tabla_resumen['count'] = df_grades.groupby(['race/ethnicity', 'simplification parental level of education']).size()
tabla_resumen

total=len(df_grades)
porcentaje=((tabla_resumen["count"]*100) / total).round(2)
tabla_resumen["percentage"]= porcentaje.astype(str)+"%"
tabla_resumen

total=len(df_grades)
porcentaje=((tabla_resumen["count"]*100) / total).round(2)
tabla_resumen["percentage"]= porcentaje.astype(str)+"%"
tabla_resumen.reset_index()

"""**Resultado Esperado**

|    | race/ethnicity   | simple parental level of education   |   math score |   reading score |   writing score |   GPA |   count | percentage   |
|---:|:-----------------|:-------------------------------------|-------------:|----------------:|----------------:|------:|--------:|:-------------|
|  0 | group A          | college                              |         4.74 |            5    |            4.89 |  4.88 |      24 | 2.74 %       |
|  1 |           | postgraduate                         |         4.69 |            5.23 |            5.35 |  5.09 |       2 | 0.23 %       |
|  2 |           | school                               |         4.57 |            4.73 |            4.56 |  4.62 |      51 | 5.83 %       |
|  3 | group B          | college                              |         5.07 |            5.26 |            5.19 |  5.18 |      54 | 6.17 %       |
|  4 |           | postgraduate                         |         4.91 |            5.69 |            5.55 |  5.38 |       5 | 0.57 %       |
|  5 |           | school                               |         4.69 |            4.89 |            4.76 |  4.78 |     107 | 12.23 %      |
|  6 | group C          | college                              |         5.02 |            5.37 |            5.35 |  5.25 |     102 | 11.66 %      |
|  7 |           | postgraduate                         |         4.92 |            5.14 |            5.1  |  5.06 |      15 | 1.71 %       |
|  8 |           | school                               |         4.76 |            5.02 |            4.92 |  4.9  |     155 | 17.71 %      |
|  9 | group D          | college                              |         5.11 |            5.25 |            5.25 |  5.2  |      70 | 8.0 %        |
| 10 |           | postgraduate                         |         5.22 |            5.54 |            5.73 |  5.5  |      20 | 2.29 %       |
| 11 |           | school                               |         5.02 |            5.13 |            5.11 |  5.09 |     149 | 17.03 %      |
| 12 | group E          | college                              |         5.54 |            5.45 |            5.45 |  5.48 |      52 | 5.94 %       |
| 13 |          | postgraduate                         |         5.54 |            6.03 |            5.89 |  5.82 |       6 | 0.69 %       |
| 14 |          | school                               |         5.4  |            5.31 |            5.16 |  5.29 |      63 | 7.2 %        |

## Visualizaciones [0.5 Puntos]

Ahora, implemente un gráfico de caja en donde se muestre el GPA con respecto al nivel educacional y que la variable de color sea la etnicidad y luego comente.
"""

import plotly.express as px

# Crea un gráfico de caja con Plotly Express
fig = px.box(df_grades, x='simplification parental level of education', y='GPA', color='race/ethnicity',
             title='Gráfico de Caja del GPA por Nivel Educacional (Color por Etnia)',
             labels={'simplification parental level of education': 'Nivel Educacional de Padres', 'GPA': 'GPA'})

# Muestra el gráfico
fig.show()

"""> 1. ¿Hay alguna diferencia entre los grupos graficados tanto para el nivel educacional de los padres como también para la etnicidad?
> 2. ¿Este gráfico permite hacer facilmente un análisis conjunto de estas dos variables de forma sencilla?

**Justifique:**

```
Escriba aqui su respuesta

¿Hay alguna diferencia entre los grupos graficados tanto para el nivel educacional de los padres como también para la etnicidad?

Si efectivamente existen diferencias, de partida existe un mayor numero de etnias para ciertos niveles educacionales como por ejemplo postgraduate los cuales presentan una mayor cantidad de estudiantes para los grupos B y E. En ciertos niveles las concentraciones son similares pero varian para los tres niveles. Referido a las medias, varian para los tres niveles educacionales pero siempre se mantiene que la etnia del grupo E presenta una mayor mediana lo cual es un hecho importante, dado que implica que ciertas etnias presentan mejor resultados que otras (lo cual no es deseable para una escuela).

¿Este gráfico permite hacer facilmente un análisis conjunto de estas dos variables de forma sencilla?

Como grupo consideramos que sí, permite sacar conclusciones rapidas considerandose el resultado como una buena visualizacion. Pero se debe destacar que si el numero de razas aumenta quizas complique la visualizacion y se deba optar por otra.
```

# 1.3.5 Combinar Dataset [1 punto]

Mientras le notificaba por videollamada los resultados de sus descubrimientos a Don Caguayo, un exaltado practicante del area de TI entra a la reunión y les informa que ha encontrado una nueva base de datos que cuenta con las notas de dos asignaturas (en escala chilena): historia y ciencias.
Para más remate, antes de huir, el practicante les cuenta que este dataframe lamentablemente contiene nuevamente los alumnos de los registros corruptos que ud. y su equipo filtraron en el análisis anterior.


El rector (evidentemente molesto por la situación) les ruega incluir estos datos (vaciados en el archivo other_grades.csv) al estudio original(`students_grades.csv`).


Para esto, carge el archivo `other_grades.csv` y busque la forma de unir ambos DataFrames, de tal manera que las columnas de `history score` y `science score` se anexen al final del DataFrame original. **NO LIMPIE LOS DATOS**, si no que explore los distintos tipos de merge para encontrar el mas situable para su situación (y así evitar buscar duplicados).

**To-Do**


- [ ] Cargar el `other_grades.csv`
- [ ] Unir `df_grades` con `other_grades.csv` usando outer join y explique el resultado.
- [ ] Unir `df_grades` con `other_grades.csv` usando left join y explique el resultado.
- [ ] Unir `df_grades` con `other_grades.csv` usando right join y explique el resultado.
- [ ] Unir `df_grades` con `other_grades.csv` usando inner join y explique el resultado.
- [ ] Defina cuál join es el que utilizará para generar el nuevo DataFrame.

> **Hint**: Puede explicar los resultados del merge a través de la cantidad de filas resultantes y los valores que estas contienen.
> **Hint**: Puede explicar los resultados del merge a través de la cantidad de filas resultantes y los valores que estas contienen.
"""

df_other_grades = pd.read_csv('other_grades.csv')
df_other_grades

merge_outer = df_grades.merge(df_other_grades, on='names', how='outer')
merge_outer

"""El método outer join une los DataFrames df_grades y other_grades, estos se combinan en función de la columna “names”. En base a esto, si existen nombres en común en ambos dataset, estos se combinarán en una fila, si no, se crearán filas con valores NaN en el nuevo DataFrame.

Esto se puede ver en el nuevo dataset formado ya que este consta de 1000 filas y con valores NaN en él, esto se debe a que df_grades contiene 875 datos mientras que other_grades contiene 1000 datos, es decir se crearon 125 nuevos datos con valores NaN.

"""

merge_left = df_grades.merge(df_other_grades, on='names', how='left')
merge_left

"""El método left join une los DataFrames df_grades y other_grades, estos se combinan utilizando una fusión “izquierda” en función de la columna “names”. Es decir, incluye todas las filas de df_grades y solamente las que coinciden en los nombres de other_grades. Si no existen coincidencias en los nombres en other_grades, se crearán filas con valores NaN en el DataFrame.

Esto se puede ver en el nuevo dataset formado ya que este consta de 875 filas, esto se debe a que df_grades contiene 875 datos mientras que other_grades contiene 1000 datos y al utilizar el método left se mantuvieron todas las filas de df_grades pudiendo completar el dataset con la información de other_grades que tuviera las notas de los alumnos del dataset original.

"""

merge_right = df_grades.merge(df_other_grades, on='names', how='right')
merge_right

"""El método right join une los DataFrames df_grades y other_grades, estos se combinan utilizando una fusión “derecha” en función de la columna “names”. Es decir, incluye todas las filas de other_grades y solamente las que coinciden en los nombres de df_grades. Si no existen coincidencias en los nombres en df_grades, se crearán filas con valores NaN en el DataFrame.

Esto se puede ver en el nuevo dataset formado ya que este consta de 1000 filas y con valores NaN en él, esto se debe a que df_grades contiene 875 datos mientras que other_grades contiene 1000 datos, es decir mantiene 125 datos con valores NaN de other_grades.

"""

merge_inner = df_grades.merge(df_other_grades, on='names', how='inner')
merge_inner

"""El método inner join une los DataFrames df_grades y other_grades, estos se combinan utilizando una fusión “interna” en función de la columna “names”. Es decir, incluye solo las filas de df_grades que coinciden con los nombres de other_grades. Si no existen coincidencias en los nombres en algún dataset, esas filas se omitirán.

Esto se puede ver en el nuevo dataset formado ya que este consta de 875 filas, esto se debe a que df_grades contiene 875 datos mientras que other_grades contiene 1000 datos y al utilizar el método inner solamente se mantuvieron todas las filas que tienen el nombre en común, pudiendo completar el dataset con la información de other_grades, omitiendo el resto que no coincide.

> **Respuesta**:

El Join que utilizaremos para generar el nuevo DataFrame es el left join, ya que en este caso nos conviene debido a que se quiere agregar columnas de información para completar el DataFrame df_grades, por lo que se rellenaría la información con los datos que ya existen.

No nos conviene utilizar other ni right debido a que se completaría con información de alumnos corruptos, agregando datos que no corresponden a la lista original.

Tampoco nos conviene utilizar el método inner debido a que se completaría según los nombres en común de ambos dataset, esto nos generara la posibilidad de que existan nombres de df_grades que no están en other_grades y por ende se eliminarían de la base de datos lo cual es un procedimiento incorrecto.

## 1.4 Más visualizaciones [0.5 puntos]


<p align="center">
  <img src="https://media4.giphy.com/media/xT5LMWNOjGqJzUfyve/giphy.gif?cid=ecf05e47phkhvg6vadqvcoobvxwj9bzxxk38jjvkcc6eak6t&rid=giphy.gif&ct=g">
</p>

Genere dos visualizaciones extras que encuentre interesantes (y no triviales) con estos datos y explique sus resultados. Agrupe los atributos que estime convenientes.


**To-Do:**
- [ ] Generar dos nuevas visualizaciones con los datos y explicar que están representando.


> **NOTA: No utilice historia ni ciencias, son notas generadas aleatoriamente.**
"""

#Grafico de histogramas segun nota por asignatura
df_final = pd.melt(merge_left, id_vars=['names'], value_vars=['math score'],var_name='subject', value_name='score')
df_final['race/ethnicity'] = merge_inner['race/ethnicity']

fig_hist = px.histogram(df_final, x='score', color='race/ethnicity', title='Histograma de Math Score por race/ethnicity',barmode = "relative", nbins=14,facet_col='race/ethnicity',facet_col_wrap=1)
fig_hist.show()

"""
```
Escriba aqui su respuesta

Este grafico permite saber como se distribuyen las notas segun etnia para la asignatura de Math, permite dislumbrar de forma mas clara como se distribuyen las notas independiente de la cantidad de estudiantes centrandose directamente en la etnia estudiada. Por ejemplo, la mayor cantidad de estudiantes de la etnia E esta prsente entre las notas 5 y 6.
```"""

df_final = pd.melt(
    merge_left,
    id_vars=['race/ethnicity'],
    value_vars=['reading score', 'math score', 'writing score'],
    var_name='subject',
    value_name='score'
)

fig_hist = px.histogram(
    df_final,
    x='score',
    color='race/ethnicity',
    marginal='box',
    title='Histograma por score de las tres asignaturas y race/ethnicity',
    barmode='group',
    nbins=14,
    facet_col='subject'  # Esto divide el histograma por 'subject' (lectura, matemáticas, escritura)
)

fig_hist.show()

"""```
Escriba aqui su respuesta

Este grafico permite saber la distribucion de los alumnos entre los rangos de notas al igual que las medias segun su etnia, en dicha imagen se aprecia que para las tres asignaturas el grupo E presenta mejor mediana teniendo una cantidad de estudiantes relativamente menor en comparacion a la etnia C y D. Dicha informacion es nueva y permite saber la masa de estudiantes de cada etnia y de como les va en comparacion al resto, lo cual no es del todo etico.
```

# Conclusión
Eso ha sido todo para el lab de hoy, recuerden que el laboratorio tiene un plazo de entrega de una semana y que **los días de atraso no se pueden utilizar para entregas de lab** solo para tareas. Cualquier duda del laboratorio, no duden en contactarnos por mail o U-cursos.

<p align="center">
  <img src="https://media1.tenor.com/images/2f7df460196625edc45b8380d158e5ee/tenor.gif?itemid=16669403">
</p>

<br>
<center>
<img src="https://i.kym-cdn.com/photos/images/original/001/194/195/b18.png" width=100 height=50 />
</center>
<br>

<a style='text-decoration:none;line-height:16px;display:flex;color:#5B5B62;padding:10px;justify-content:end;' href='https://deepnote.com?utm_source=created-in-deepnote-cell&projectId=87110296-876e-426f-b91d-aaf681223468' target="_blank">
<img alt='Created in deepnote.com' style='display:inline;max-height:16px;margin:0px;margin-right:7.5px;' src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iODBweCIgaGVpZ2h0PSI4MHB4IiB2aWV3Qm94PSIwIDAgODAgODAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDU0LjEgKDc2NDkwKSAtIGh0dHBzOi8vc2tldGNoYXBwLmNvbSAtLT4KICAgIDx0aXRsZT5Hcm91cCAzPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IkxhbmRpbmciIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJBcnRib2FyZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEyMzUuMDAwMDAwLCAtNzkuMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0zIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjM1LjAwMDAwMCwgNzkuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0yMCIgZmlsbD0iIzAyNjVCNCIgcG9pbnRzPSIyLjM3NjIzNzYyIDgwIDM4LjA0NzY2NjcgODAgNTcuODIxNzgyMiA3My44MDU3NTkyIDU3LjgyMTc4MjIgMzIuNzU5MjczOSAzOS4xNDAyMjc4IDMxLjY4MzE2ODMiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNS4wMDc3MTgsODAgQzQyLjkwNjIwMDcsNzYuNDU0OTM1OCA0Ny41NjQ5MTY3LDcxLjU0MjI2NzEgNDguOTgzODY2LDY1LjI2MTk5MzkgQzUxLjExMjI4OTksNTUuODQxNTg0MiA0MS42NzcxNzk1LDQ5LjIxMjIyODQgMjUuNjIzOTg0Niw0OS4yMTIyMjg0IEMyNS40ODQ5Mjg5LDQ5LjEyNjg0NDggMjkuODI2MTI5Niw0My4yODM4MjQ4IDM4LjY0NzU4NjksMzEuNjgzMTY4MyBMNzIuODcxMjg3MSwzMi41NTQ0MjUgTDY1LjI4MDk3Myw2Ny42NzYzNDIxIEw1MS4xMTIyODk5LDc3LjM3NjE0NCBMMzUuMDA3NzE4LDgwIFoiIGlkPSJQYXRoLTIyIiBmaWxsPSIjMDAyODY4Ij48L3BhdGg+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMCwzNy43MzA0NDA1IEwyNy4xMTQ1MzcsMC4yNTcxMTE0MzYgQzYyLjM3MTUxMjMsLTEuOTkwNzE3MDEgODAsMTAuNTAwMzkyNyA4MCwzNy43MzA0NDA1IEM4MCw2NC45NjA0ODgyIDY0Ljc3NjUwMzgsNzkuMDUwMzQxNCAzNC4zMjk1MTEzLDgwIEM0Ny4wNTUzNDg5LDc3LjU2NzA4MDggNTMuNDE4MjY3Nyw3MC4zMTM2MTAzIDUzLjQxODI2NzcsNTguMjM5NTg4NSBDNTMuNDE4MjY3Nyw0MC4xMjg1NTU3IDM2LjMwMzk1NDQsMzcuNzMwNDQwNSAyNS4yMjc0MTcsMzcuNzMwNDQwNSBDMTcuODQzMDU4NiwzNy43MzA0NDA1IDkuNDMzOTE5NjYsMzcuNzMwNDQwNSAwLDM3LjczMDQ0MDUgWiIgaWQ9IlBhdGgtMTkiIGZpbGw9IiMzNzkzRUYiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+' > </img>
Created in <span style='font-weight:600;margin-left:4px;'>Deepnote</span></a>
"""